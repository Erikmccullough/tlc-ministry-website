<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Bubble Puppet (Swipe + Dip)</title>
<style>
  html, body {
    margin:0; padding:0; height:100%; width:100%;
    background:#000; overflow:hidden;
    touch-action:none;
    font-family: -apple-system, system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
  }
  #c { display:block; width:100vw; height:100vh; }
  #hud {
    position:fixed;
    left:12px; right:12px;
    bottom: max(12px, env(safe-area-inset-bottom));
    color: rgba(255,255,255,0.92);
    text-shadow: 0 2px 10px rgba(0,0,0,0.7);
    font-size: 14px; line-height: 1.25;
    pointer-events:none;
  }
  #pill {
    display:inline-block;
    padding:10px 12px;
    border-radius: 14px;
    background: rgba(0,0,0,0.35);
    backdrop-filter: blur(6px);
    -webkit-backdrop-filter: blur(6px);
    border: 1px solid rgba(255,255,255,0.18);
  }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="hud"><span id="pill"><b>Swipe up/down</b> on the torso to open/close the poles. <b>Tap the bucket</b> to dip the string.</span></div>

<script>
(() => {
  const cfg = {"W": 1006, "H": 1536, "left": {"origin": [197, 500], "pivot": [223, 260], "tip": [103.5, 23.0], "size": [308, 372]}, "right": {"origin": [517, 500], "pivot": [68, 260], "tip": [199.0, 23.0], "size": [360, 372]}, "bubble": {"origin": [121, 101], "pivot": [382, 239]}, "bucket": {"center": [690, 1335], "radius": 120}, "torso_zone": {"x0": 0.36, "x1": 0.64, "y0": 0.4, "y1": 0.68}, "bucket_zone": {"x0": 0.58, "x1": 0.84, "y0": 0.8, "y1": 0.98}};
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const DPR = () => Math.min(3, window.devicePixelRatio || 1);

  const imgs = {};
  const load = (name, src) => new Promise((res, rej) => {
    const i = new Image();
    i.onload = () => (imgs[name]=i, res(i));
    i.onerror = rej;
    i.src = src;
  });

  const assets = {
    bg: 'bg.png',
    left: 'left.png',
    right:'right.png',
    bubble:'bubble.png'
  };

  // Interaction state
  let t = 1.0;        // 0 down/closed, 1 up/open
  let tTarget = 1.0;
  let isSwiping = false;

  // Dip state machine
  let dipActive = false;
  let dipStart = 0;
  let bubbleCharge = 1.0;   // 0..1 (needs fresh soap film)
  let bubbleGrow = 0.85;    // 0..1 (visual "formedness")
  let lastTapTime = 0;

  const ease = (u) => (u<0.5) ? 4*u*u*u : 1 - Math.pow(-2*u+2, 3)/2;

  function worldScale() {
    return Math.min(canvas.clientWidth / cfg.W, canvas.clientHeight / cfg.H);
  }
  function worldOffset(scale) {
    return {
      dx: (canvas.clientWidth - cfg.W * scale) * 0.5,
      dy: (canvas.clientHeight - cfg.H * scale) * 0.5
    };
  }

  function inRectNorm(px, py, r) {
    const nx = px / canvas.clientWidth;
    const ny = py / canvas.clientHeight;
    return (nx >= r.x0 && nx <= r.x1 && ny >= r.y0 && ny <= r.y1);
  }

  function inTorsoZone(px, py) {
    return inRectNorm(px, py, cfg.torso_zone);
  }
  function inBucketZone(px, py) {
    return inRectNorm(px, py, cfg.bucket_zone);
  }

  function pointerToT(py) {
    const h = canvas.clientHeight;
    // map y in [0.70h .. 0.40h] -> t in [0 .. 1]
    const y0 = 0.70*h, y1 = 0.40*h;
    const tt = (y0 - py) / (y0 - y1);
    return Math.max(0, Math.min(1, tt));
  }

  function startDip(nowMs) {
    // debounce quick taps
    if (nowMs - lastTapTime < 250) return;
    lastTapTime = nowMs;

    dipActive = true;
    dipStart = nowMs;

    // "soap film used" â€“ bubble fades while dipping, reforms after
    bubbleCharge = 0.0;
    bubbleGrow = 0.0;

    // also stop swipe
    isSwiping = false;
  }

  function onDown(e) {
    const p = e.touches ? e.touches[0] : e;

    // Tap bucket to dip
    if (inBucketZone(p.clientX, p.clientY)) {
      startDip(performance.now());
      e.preventDefault();
      return;
    }

    // Swipe torso to puppet poles
    if (!inTorsoZone(p.clientX, p.clientY)) return;
    isSwiping = true;
    tTarget = pointerToT(p.clientY);
    e.preventDefault();
  }

  function onMove(e) {
    if (!isSwiping) return;
    const p = e.touches ? e.touches[0] : e;
    tTarget = pointerToT(p.clientY);
    e.preventDefault();
  }
  function onUp() {
    isSwiping = false;
  }

  window.addEventListener('touchstart', onDown, {passive:false});
  window.addEventListener('touchmove', onMove, {passive:false});
  window.addEventListener('touchend', onUp);
  window.addEventListener('mousedown', onDown);
  window.addEventListener('mousemove', onMove);
  window.addEventListener('mouseup', onUp);

  function resize() {
    const dpr = DPR();
    canvas.width = Math.floor(window.innerWidth * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', resize);

  // Draw sprite with rotation around pivot
  function drawSpriteRot(name, part, angleRad) {
    const img = imgs[name];
    const scale = worldScale();
    const {dx,dy} = worldOffset(scale);

    const ox = part.origin[0], oy = part.origin[1];
    const px = part.pivot[0],  py = part.pivot[1];

    const x = dx + ox * scale;
    const y = dy + oy * scale;

    ctx.save();
    ctx.translate(x + px*scale, y + py*scale);
    ctx.rotate(angleRad);
    ctx.translate(-px*scale, -py*scale);
    ctx.drawImage(img, 0, 0, img.width*scale, img.height*scale);
    ctx.restore();
  }

  // Transform a point in sprite-local coordinates to world/screen coordinates
  function xformPoint(part, angleRad, localPt) {
    const scale = worldScale();
    const {dx,dy} = worldOffset(scale);

    const ox = part.origin[0], oy = part.origin[1];
    const px = part.pivot[0],  py = part.pivot[1];

    const lx = localPt[0], ly = localPt[1];

    // rotate around pivot in sprite space
    const sx = lx - px;
    const sy = ly - py;
    const ca = Math.cos(angleRad), sa = Math.sin(angleRad);
    const rx = sx*ca - sy*sa;
    const ry = sx*sa + sy*ca;

    const wx = (ox + px + rx) * scale + dx;
    const wy = (oy + py + ry) * scale + dy;
    return [wx, wy];
  }

  function bucketCenterScreen() {
    const scale = worldScale();
    const {dx,dy} = worldOffset(scale);
    return [dx + cfg.bucket.center[0]*scale, dy + cfg.bucket.center[1]*scale];
  }

  function drawStringAndLoop(TL, TR, tNow, dipAmt) {
    const scale = worldScale();
    const mid = [(TL[0]+TR[0])*0.5, (TL[1]+TR[1])*0.5];
    const bucket = bucketCenterScreen();

    // Top string: slightly bowed
    const lift = (1 - tNow) * 18 + Math.sin(performance.now()/1000*1.4)*2;
    const cTop = [mid[0], mid[1] + lift];

    // Bottom string: sagging + dip toward bucket
    const baseSag = (1 - tNow) * 220 + 40; // down when closed
    let cBot = [mid[0], mid[1] + baseSag];

    // During dip, pull control point toward bucket and deeper
    if (dipAmt > 0) {
      const pull = dipAmt;
      cBot = [
        cBot[0]*(1-pull) + bucket[0]*pull,
        cBot[1]*(1-pull) + (bucket[1]-10)*pull
      ];
    }

    // Draw
    ctx.save();
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    // dark core line
    ctx.strokeStyle = 'rgba(0,0,0,0.65)';
    ctx.lineWidth = Math.max(1.2, 2.0*scale);

    // top
    ctx.beginPath();
    ctx.moveTo(TL[0], TL[1]);
    ctx.quadraticCurveTo(cTop[0], cTop[1], TR[0], TR[1]);
    ctx.stroke();

    // bottom
    ctx.beginPath();
    ctx.moveTo(TL[0], TL[1]);
    ctx.quadraticCurveTo(cBot[0], cBot[1], TR[0], TR[1]);
    ctx.stroke();

    // subtle highlight
    ctx.strokeStyle = 'rgba(255,255,255,0.20)';
    ctx.lineWidth = Math.max(0.8, 1.1*scale);

    ctx.beginPath();
    ctx.moveTo(TL[0], TL[1]-0.5);
    ctx.quadraticCurveTo(cTop[0], cTop[1]-0.5, TR[0], TR[1]-0.5);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(TL[0], TL[1]+0.5);
    ctx.quadraticCurveTo(cBot[0], cBot[1]+0.5, TR[0], TR[1]+0.5);
    ctx.stroke();

    // little "soap drip" sparkle when dipping
    if (dipAmt > 0.55) {
      const dripX = cBot[0];
      const dripY = cBot[1] + 8;
      ctx.fillStyle = 'rgba(255,255,255,0.25)';
      for (let i=0;i<6;i++) {
        const a = i*1.2 + performance.now()/1000;
        const r = (6 + i*2) * scale;
        ctx.beginPath();
        ctx.arc(dripX + Math.cos(a)*r, dripY + Math.sin(a*1.3)*r, 1.2*scale, 0, Math.PI*2);
        ctx.fill();
      }
    }

    ctx.restore();
  }

  function drawBubble(time, tNow, dipAmt) {
    const img = imgs.bubble;

    const scale = worldScale();
    const {dx,dy} = worldOffset(scale);

    const ox = cfg.bubble.origin[0], oy = cfg.bubble.origin[1];
    const px = cfg.bubble.pivot[0],  py = cfg.bubble.pivot[1];

    const x = dx + ox * scale;
    const y = dy + oy * scale;

    const wob = Math.sin(time*1.7) * (0.018 + 0.020*tNow);
    const wob2 = Math.cos(time*1.2) * (0.014 + 0.018*tNow);

    // bubble reforms after dip: bubbleGrow ramps
    bubbleGrow = Math.min(1.0, bubbleGrow + (0.010 + 0.020*tNow));

    const sx = 1 + 0.05*tNow + wob + 0.10*bubbleGrow;
    const sy = 1 + 0.12*tNow + wob2 + 0.20*bubbleGrow;

    const rot = Math.sin(time*0.9) * (0.02 + 0.02*tNow);

    // Fade out during dip, brighten as it forms
    const alpha = (0.15 + 0.85*(1 - dipAmt)) * (0.35 + 0.65*tNow) * (0.20 + 0.80*bubbleGrow) * (0.35 + 0.65*bubbleCharge);

    ctx.save();
    ctx.translate(x + px*scale, y + py*scale);
    ctx.rotate(rot);
    ctx.scale(sx, sy);

    ctx.globalAlpha = alpha;
    const prevComp = ctx.globalCompositeOperation;
    ctx.globalCompositeOperation = 'lighter';

    ctx.translate(-px*scale, -py*scale);
    ctx.drawImage(img, 0, 0, img.width*scale, img.height*scale);

    ctx.globalCompositeOperation = prevComp;
    ctx.restore();
  }

  function render(timeMs) {
    const time = timeMs/1000;

    // Dip animation curve
    let dipAmt = 0;
    if (dipActive) {
      const d = (timeMs - dipStart);
      const dur = 1400;
      const p = Math.max(0, Math.min(1, d / dur));

      // descend 0..0.45, dwell 0.45..0.60, rise 0.60..1.0
      if (p < 0.45) dipAmt = ease(p/0.45);
      else if (p < 0.60) dipAmt = 1;
      else dipAmt = 1 - ease((p-0.60)/0.40);

      // after complete
      if (p >= 1) {
        dipActive = false;
        dipAmt = 0;
        bubbleCharge = 1.0;
        bubbleGrow = 0.15; // it starts small again, then inflates
      }
    }

    // During dip, guide arms down a bit automatically
    const tDipTarget = dipActive ? Math.min(tTarget, 0.18) : tTarget;

    // Smooth follow
    t += (tDipTarget - t) * 0.18;

    // Bubble "charge" slowly decays with time (acts used up)
    bubbleCharge = Math.max(0.0, bubbleCharge - 0.00025);

    // Clear
    ctx.clearRect(0,0,canvas.clientWidth, canvas.clientHeight);

    // Background
    const bg = imgs.bg;
    const scale = worldScale();
    const {dx,dy} = worldOffset(scale);
    ctx.drawImage(bg, dx, dy, cfg.W*scale, cfg.H*scale);

    // Angles: open/close poles via arm rotation
    const deg = (d) => d*Math.PI/180;
    const aL = deg(75*(1-t));
    const aR = deg(-75*(1-t));

    // Compute pole tips in screen space from sprite tips
    const TL = xformPoint(cfg.left, aL, cfg.left.tip);
    const TR = xformPoint(cfg.right, aR, cfg.right.tip);

    // Draw strings behind bubble (like real life)
    drawStringAndLoop(TL, TR, t, dipAmt);

    // Bubble responds to open-ness + dip
    drawBubble(time, t, dipAmt);

    // Arms/poles on top (they include the rods)
    drawSpriteRot('left', cfg.left, aL);
    drawSpriteRot('right', cfg.right, aR);

    // HUD fades slightly during swipe
    const hud = document.getElementById('hud');
    hud.style.opacity = (isSwiping || dipActive) ? '0.30' : '1.0';

    requestAnimationFrame(render);
  }

  Promise.all([
    load('bg', assets.bg),
    load('left', assets.left),
    load('right', assets.right),
    load('bubble', assets.bubble),
  ]).then(() => {
    resize();
    requestAnimationFrame(render);
  }).catch(err => {
    document.getElementById('pill').textContent = 'Failed to load images: ' + err;
  });
})();
</script>
</body>
</html>
