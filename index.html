<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Swipe Puppet Bubble</title>
<style>
  html, body {
    margin:0; padding:0; height:100%; width:100%;
    background:#000; overflow:hidden; touch-action:none;
    font-family: -apple-system, system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
  }
  #c {
    display:block;
    width:100vw; height:100vh;
  }
  #hint {
    position:fixed;
    left:12px; right:12px; bottom: max(12px, env(safe-area-inset-bottom));
    color: rgba(255,255,255,0.92);
    text-shadow: 0 2px 10px rgba(0,0,0,0.7);
    font-size: 14px;
    line-height: 1.25;
    pointer-events:none;
  }
  #hint b {
    font-weight: 700;
  }
  #pill {
    display:inline-block;
    padding:10px 12px;
    border-radius: 14px;
    background: rgba(0,0,0,0.35);
    backdrop-filter: blur(6px);
    -webkit-backdrop-filter: blur(6px);
    border: 1px solid rgba(255,255,255,0.18);
  }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="hint"><span id="pill"><b>Swipe up/down</b> over the torso to raise/lower the arms. The bubble “breathes” with you.</span></div>

<script>
(() => {
  const cfg = {"W": 1006, "H": 1536, "left": {"origin": [197, 500], "pivot": [223, 260]}, "right": {"origin": [517, 500], "pivot": [68, 260]}, "bubble": {"origin": [121, 101], "pivot": [382, 239]}};
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const DPR = () => Math.min(3, window.devicePixelRatio || 1);

  const imgs = {};
  const load = (name, src) => new Promise((res, rej) => {
    const i = new Image();
    i.onload = () => (imgs[name]=i, res(i));
    i.onerror = rej;
    i.src = src;
  });

  // Assets next to this HTML
  const assets = {
    bg: 'bg.png',
    left: 'left.png',
    right:'right.png',
    bubble:'bubble.png'
  };

  let t = 1.0;           // 0 arms down, 1 arms up
  let tTarget = 1.0;
  let isDown = false;

  // "Torso swipe zone" in normalized coords (rough but effective)
  function inTorsoZone(px, py) {
    const nx = px / canvas.clientWidth;
    const ny = py / canvas.clientHeight;
    return (nx > 0.36 && nx < 0.64 && ny > 0.40 && ny < 0.68);
  }

  function pointerToT(py) {
    const h = canvas.clientHeight;
    // map y in [0.70h .. 0.40h] -> t in [0 .. 1]
    const y0 = 0.70*h, y1 = 0.40*h;
    const tt = (y0 - py) / (y0 - y1);
    return Math.max(0, Math.min(1, tt));
  }

  function onDown(e) {
    const p = e.touches ? e.touches[0] : e;
    if (!inTorsoZone(p.clientX, p.clientY)) return; // require torso-ish contact
    isDown = true;
    tTarget = pointerToT(p.clientY);
    e.preventDefault();
  }
  function onMove(e) {
    if (!isDown) return;
    const p = e.touches ? e.touches[0] : e;
    tTarget = pointerToT(p.clientY);
    e.preventDefault();
  }
  function onUp() {
    isDown = false;
  }

  window.addEventListener('touchstart', onDown, {passive:false});
  window.addEventListener('touchmove', onMove, {passive:false});
  window.addEventListener('touchend', onUp);
  window.addEventListener('mousedown', onDown);
  window.addEventListener('mousemove', onMove);
  window.addEventListener('mouseup', onUp);

  function resize() {
    const dpr = DPR();
    canvas.width = Math.floor(window.innerWidth * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', resize);

  function drawSpriteRot(name, originXY, pivotXY, angleRad) {
    const img = imgs[name];
    const ox = originXY[0], oy = originXY[1];
    const px = pivotXY[0], py = pivotXY[1];

    // Map original-image coords -> screen coords via scale that preserves aspect
    const scale = Math.min(canvas.clientWidth / cfg.W, canvas.clientHeight / cfg.H);
    const dx = (canvas.clientWidth - cfg.W * scale) * 0.5;
    const dy = (canvas.clientHeight - cfg.H * scale) * 0.5;

    const x = dx + ox * scale;
    const y = dy + oy * scale;

    ctx.save();
    ctx.translate(x + px*scale, y + py*scale);
    ctx.rotate(angleRad);
    ctx.translate(-px*scale, -py*scale);
    ctx.drawImage(img, 0, 0, img.width*scale, img.height*scale);
    ctx.restore();
  }

  function drawBubble(time) {
    const img = imgs.bubble;

    const scale = Math.min(canvas.clientWidth / cfg.W, canvas.clientHeight / cfg.H);
    const dx = (canvas.clientWidth - cfg.W * scale) * 0.5;
    const dy = (canvas.clientHeight - cfg.H * scale) * 0.5;

    const ox = cfg.bubble.origin[0], oy = cfg.bubble.origin[1];
    const px = cfg.bubble.pivot[0],  py = cfg.bubble.pivot[1];

    const x = dx + ox * scale;
    const y = dy + oy * scale;

    const wob = Math.sin(time*1.7) * (0.018 + 0.020*t);
    const wob2 = Math.cos(time*1.2) * (0.014 + 0.018*t);

    const sx = 1 + 0.05*t + wob;
    const sy = 1 + 0.12*t + wob2;

    const rot = Math.sin(time*0.9) * (0.02 + 0.02*t);

    ctx.save();
    ctx.translate(x + px*scale, y + py*scale);
    ctx.rotate(rot);
    ctx.scale(sx, sy);

    // brighter when arms are higher
    ctx.globalAlpha = 0.65 + 0.25*t;
    const prevComp = ctx.globalCompositeOperation;
    ctx.globalCompositeOperation = 'lighter';
    ctx.translate(-px*scale, -py*scale);
    ctx.drawImage(img, 0, 0, img.width*scale, img.height*scale);
    ctx.globalCompositeOperation = prevComp;
    ctx.restore();
  }

  function render(timeMs) {
    const time = timeMs/1000;

    // Smooth follow
    t += (tTarget - t) * 0.18;

    // Clear
    ctx.clearRect(0,0,canvas.clientWidth, canvas.clientHeight);

    // Base: cleaned background (arms mostly removed), keeps original vibe
    const bg = imgs.bg;
    const scale = Math.min(canvas.clientWidth / cfg.W, canvas.clientHeight / cfg.H);
    const dx = (canvas.clientWidth - cfg.W * scale) * 0.5;
    const dy = (canvas.clientHeight - cfg.H * scale) * 0.5;
    ctx.drawImage(bg, dx, dy, cfg.W*scale, cfg.H*scale);

    // Bubble responds
    drawBubble(time);

    // Arms: rotate down/up
    const deg = (d) => d*Math.PI/180;

    // Down angles (t=0) -> Up angles (t=1)
    const aL = deg(75*(1-t));     // left rotates clockwise when lowering
    const aR = deg(-75*(1-t));    // right rotates counter-clockwise when lowering

    drawSpriteRot('left', cfg.left.origin, cfg.left.pivot, aL);
    drawSpriteRot('right', cfg.right.origin, cfg.right.pivot, aR);

    // Hint fades after interaction
    const hint = document.getElementById('hint');
    if (isDown) {
      hint.style.opacity = '0.15';
    }

    requestAnimationFrame(render);
  }

  Promise.all([
    load('bg', assets.bg),
    load('left', assets.left),
    load('right', assets.right),
    load('bubble', assets.bubble),
  ]).then(() => {
    resize();
    requestAnimationFrame(render);
  }).catch(err => {
    document.getElementById('pill').textContent = 'Failed to load images: ' + err;
  });
})();
</script>
</body>
</html>
